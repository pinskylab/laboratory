---
title: "`r params$first` - `r params$last` on Robot"
params:
  first: D3479
  infile: data/samples_to_ligate.Rdata
  last: D6496
  regeno_first: NA
  regeno_last: NA
  rxn_size: 15
  date_of_work: '2018-08-06'
  max_lig: 5186
  pool: P127
  infile1: "/Volumes/USB DISK/robot files/2018-08-0322_a.csv"
  infile2: "/Volumes/USB DISK/robot files/2018-08-0322_b.csv"
  infile3: "/Volumes/USB DISK/robot files/2018-08-0322_c.csv"
  infile4: "/Volumes/USB DISK/robot files/2018-08-0322_d.csv"
output:
  html_notebook:
    code_folding: hide
    df_print: paged
---

## Prep
<!-- TODO: read up on ggplot2 to make a multipanel graph that is a representation of all of the plates and locations on the robot bench the way that you normally draw them...for example 1st plot in multipanel would just be  "D4588/P5" in the center of the graph space following the formula plan$source_plate / plan$source_loc -->


```{r setup, echo=FALSE, message=FALSE}
source("../genomics/scripts/lab_helpers.R")
library(knitr)
library(kableExtra)

# connect to the db
lab <- write_db("Laboratory")

# define samples to be ligated (if known)
dig_min <- params$first
dig_max <- params$last

# define digests that have been digested for the sole purpose of serving as regenotypes (if known)
regeno_min <- params$regeno_first
regeno_max <- params$regeno_last
```

Pull digest info from db - not doing this, using the data from the infile instead.
```{r get_data, echo=FALSE, message=FALSE}
digs <- readRDS(params$infile)
  
dig <- dbReadTable(lab, "digest") %>%
  filter(digest_id %in% digs$digest_id) %>%
  select(digest_id, quant, well, plate, notes) %>%
  arrange(digest_id) %>% 
  filter(quant >= 2.25, # anything below this amount cannot be ligated at 50ng or higher
         !grepl("empty", notes), 
         !grepl("contaiminated", notes), 
         !grepl("not enough", notes)) 

# There are fewer digests from the db than the infile, why? Because the quants are too low.
# missing <- anti_join(digs, dig, by = "digest_id")


regeno <- dbReadTable(lab, "digest") %>%
  filter(digest_id >= regeno_min & digest_id <= regeno_max & extraction_id != "XXXX") %>%
  select(digest_id, quant, well, plate) %>%
  arrange(quant)

dig <- dig %>% 
  filter(!digest_id %in% regeno$digest_id)
```
Create a list of pool names based on the last pool used in the database
```{r pools, echo=FALSE, message=FALSE}
# get a list (in table form) of all of the numbers used as pools so far
all <- lab %>% 
  tbl("ligation") %>% 
  select(pool) %>% 
  distinct() %>% 
  collect() %>% 
  filter(grepl("P", pool)) %>% 
  mutate(pool = as.numeric(substr(pool, 2, 4)))

non_clown_pools <- tibble(pool = c("P028", "P029",  "P034", "P035", "P036", "P037", "P038", "P043", "P044", "P045", "P046", "P047", "P048", "P049", "P050", "P051", "P052") ) %>% 
  mutate(pool = as.numeric(substr(pool, 2, 4)))

clown <- anti_join(all, non_clown_pools, by = "pool")

# what are the lowest and highest numbers used?
lims <- all %>% 
  summarise(max = max(pool), 
    min = min(pool))


# are there any missing numbers that are useable?
pool_names <- tibble(pool = lims$min:lims$max) %>% 
  filter(!pool %in% all$pool)

# how many more pool names do we need?
need <- tibble(pool = 85:(85+floor((nrow(dig)/47) - nrow(pool_names))))

pool_names <- rbind(pool_names, need) %>% 
  mutate(pool = paste("P", pool, sep = "")) %>% 
  rename(new_pool = pool)

rm(need, lims, all)  
```


Use the lig_ng method to assign ligation amounts to samples and to create pools of 47 samples, leaving room for 1 regenotype sample in each pool.  Not all pools are getting a regenotype.
```{r lig_ng, echo=FALSE, message=FALSE}

out <- data.frame() # make a blank data frame to write to
for(i in c(200, 150, 100, 75, 50)){
  # get all possible regeno for this ligation amount
  x <- regeno %>%
    mutate(uL_in = round(i/quant, 1)) %>% # round to 1 decimal point
    filter(uL_in < (params$rxn_size/1.35) & uL_in > 0.5) %>%
    mutate(water = round((params$rxn_size/1.35)-uL_in, 1), 
           DNA = i)
  
  # get all possible originals for this ligation amount
  y <- dig %>%
    mutate(uL_in = round(i/quant, 1)) %>% # round to 1 decimal point
    filter(uL_in < (params$rxn_size/1.35) & uL_in > 0.5) %>%
    mutate(water = round((params$rxn_size/1.35)-uL_in, 1), 
           DNA = i)
  
  # the following few lines (through 108) are to remove the lines that aren't going to make it into pools and are the lowest volumes so that we can sort by plate and it won't matter that low volumes are mixed with high.
  # how many rows aren't going to fit into pools? Calculate the remainder left after dividing by 48
  left <- nrow(y)%%48
  # what is the last row that can be put into a pool (this is slightly more because we are going to replace some of these with regenos)
  end <- nrow(y) - left
  y <- y %>% 
    slice(1:end)

   
   # if there are any regenos left
   if (nrow(x) > 0){
     # then we need at least 47 originals to complete the pool
     if (nrow(y)/47 >= 1){ 
       for(j in 1:nrow(x)){
         pool_a <- x %>% 
           arrange(desc(uL_in)) %>% 
           slice(1)
         x <- anti_join(x, pool_a, by = "digest_id")
         pool_b <- y %>%
           arrange(plate) %>% # sort by plate to keep the lowest number of plates in a robot round
           slice(1:47)
         pool <- rbind(pool_a, pool_b) %>% 
           mutate(pool = paste("pool", i, j, sep = "_"))
         out <- rbind(out, pool)
         y <- anti_join(y, out, by = "digest_id")
       }
       if (nrow(y) >= 48){
         for(j in 1:(nrow(y)/48)){
           pool <- y %>%
             arrange(plate) %>% # keep the largest pipet volumes
             slice(1:48) %>% 
             mutate(pool = paste("pool_b", i, j, sep = "_"))
           out <- rbind(out, pool)
         y <- anti_join(y, out, by = "digest_id")
         }
       }
     dig <- anti_join(dig, out, by = "digest_id")
     regeno <- anti_join(regeno, out, by = "digest_id")
   }
   }else{
  if (nrow(y) >= 48){
         for(j in 1:(nrow(y)/48)){
           pool <- y %>%
             arrange(plate) %>% # keep the largest pipet volumes
             slice(1:48) %>% 
             mutate(pool = paste("pool_c", i, j, sep = "_"))
           out <- rbind(out, pool)
         y <- anti_join(y, out, by = "digest_id")
         }
       }
     dig <- anti_join(dig, out, by = "digest_id")
   }
}

# test how many samples are in each pool?
test <- out %>% 
  group_by(pool) %>% 
  summarise(count = n())

num_pools <- nrow(test)
pool_names <- pool_names %>% 
  slice(1:num_pools)
rm(clown, non_clown_pools, pool, pool_a, pool_b, regeno, test, x, y)
```

Define destination and source plates
```{r plates, echo=FALSE, message=FALSE}
out <- out %>%
  rename(source_well = well,
    source_plate = plate) %>%
  mutate(source_loc = NA)
# how many plates are there?
nplates <- nrow(out)/96
# what are the pool names
pool_list <- distinct(out, pool)
# attach pool names
pool_names <- cbind(pool_names, pool_list) %>% 
  rename()
# set up the plate
plate <- data_frame()
# define wells
well <- data.frame("well" = 1:(96*nplates))


for (i in seq(nplates)){
  # define first pool of the i plate
  pool1 <- out %>% 
    filter(pool == pool_list$pool[1]) %>% 
    select(digest_id)
  # define second pool of the i plate
  pool2 <- out %>% 
    filter(pool == pool_list$pool[2]) %>% 
    select(digest_id)
    a <- 96*i-95 # position 1
    b <- 96*i-48     # position 48
    c <- 96*i-47 # position 49
    d <- 96*i # position 96
    temp <- cbind(well$well[a:b], pool1)
    colnames(temp) <- c("well", "digest_id")
    temp2 <- cbind(well$well[c:d], pool2)
    colnames(temp2) <- c("well", "digest_id")
    temp <- rbind(temp, temp2) %>% 
      mutate(row = rep(LETTERS[1:8], 12), 
        col = unlist(lapply(1:12, rep, 8)), 
        round = i)
    plate <- rbind(plate, temp)
    # remove pools from list because they have been used
    pool_list <- pool_list %>% 
      slice(3:nrow(pool_list))
}

plate <- plate %>% 
  mutate(dest_loc = "P12", 
    dest_well = paste(row, col, sep = ""), 
    water_loc = "P11", 
    water_well = "A1", 
    tip1_loc = "P8", 
    tip2_loc = "P10")

rm(pool_list, pool1, pool2, temp, temp2, a,b,c,d, i)

ligations <- left_join(plate, out, by = "digest_id") %>% 
  select(-well, -row, -col)


# rename pools
ligations <- left_join(ligations, pool_names, by = "pool") %>% 
  select(-pool) %>% 
  rename(pool = new_pool)

# create source plates for each of the destination plates ####
plate_list <- distinct(ligations, round)

```
```{r write_positions, echo=FALSE, message=FALSE, results='asis'}
# for each round, define which source plates are present and assign source locations
for (i in seq(plate_list$round)){
# for (i in 6){
  # narrow the info down to only the round in question
  dest_plate <- ligations %>% filter(round == plate_list$round[i])
  # Make a table of source plates
  sources <- distinct(dest_plate, source_plate) 
  # Determine how many rounds of source plates it will take to complete the destination plate
  num_rounds <- ceiling(nrow(sources)/5) # because 5 possible positions
  reps <- ceiling(nrow(sources)/num_rounds)
  # Define possible source locations and adjust to fit the number of source plates
  #P8 is tips, P11 is water, P12 is destination
  positions <- tibble(loc = rep(c("P5", "P6", "P7", "P9", "P13"),num_rounds )) %>% 
    slice(1:nrow(sources))
  rounds <- tibble(round = rep(letters[1:num_rounds], reps)) %>% 
    slice(1:nrow(sources)) %>% 
    arrange(round)
# Create a table of plates, round designation, and position
  sources <- cbind(sources, rounds, positions)

  # match the source table to the ligation table
  for (j in seq(nrow(sources))){
    ligations <- ligations %>% 
      mutate(source_loc = ifelse(digest_id %in% dest_plate$digest_id & source_plate == sources$source_plate[j], 
                                 sources$loc[j], source_loc), 
             round = ifelse(digest_id %in% dest_plate$digest_id & source_plate == sources$source_plate[j],paste(round, sources$round[j], sep = "_"), round))
  }
  
  # separate the rounds into csv files
  temp <- ligations %>% 
    filter(digest_id %in% dest_plate$digest_id)
  rounds <- distinct(rounds)
  for(b in seq(rounds$round)){
    temp1 <- temp %>% 
      filter(grepl(rounds$round[b], round))
    write.csv(temp1, file = paste("data/", Sys.Date(), "_", temp1$round[1], ".csv", sep = ""))
   # print(kable(temp1, "latex", longtable = T, booktabs = T, caption = temp1$round[1]) %>% 
   #    kable_styling(latex_options = c("repeat_header")))
  }
}

```

```{r echo=FALSE, message=FALSE}
# add ligations to database ####

# fetch last used ligation_id
lig_max <- dbReadTable(lab, "ligation") %>%
  summarise(lig_id = max(ligation_id)) %>%
  mutate(lig_id = as.numeric(substr(lig_id, 2, 5)))

# pool_max <- dbReadTable(lab, "ligation") %>%
#   summarise(pool = max(pool)) %>%
#   mutate(pool = as.numeric(substr(pool, 2, 5)))

ligations <- ligations %>%
  mutate(ligation_id = (1+lig_max$lig_id):(nrow(ligations) + lig_max$lig_id),
    ligation_id = paste("L", ligation_id, sep = "")) %>%
  mutate(pool = paste("P", formatC(as.numeric(substr(pool, 2, 6)), width = 3, format = "d", flag = 0), sep = "")) %>%
  rename(vol_in = uL_in,
         well = dest_well) %>%
  select(ligation_id, digest_id, well, vol_in, DNA, water, pool)



## add to db
# dbWriteTable(lab, "ligation", ligations, append = T, row.names = F)
# dbDisconnect(lab)
# rm(lab)
```



<!-- Make note of the digests that are too low to ligate at 50ng or higher -->
<!-- ```{r low, echo=FALSE, message=FALSE} -->
<!-- dat_db <- lab %>%  -->
<!--   tbl("digest") %>%  -->
<!--   collect() -->

<!-- change <- readRDS(params$infile) %>%  -->
<!--   filter(quant < 2.25) %>%  -->
<!--   select(-sample_id) %>%  -->
<!--   mutate(notes = ifelse(is.na(notes), "not enough DNA to ligate at 50ng or higher", paste(notes, ", not enough DNA to ligate at 50ng or higher", sep = ""))) -->

<!-- dat_db <- change_rows(dat_db, change, "digest_id") -->

<!-- # dbWriteTable(lab, "digest", dat_db, row.names=F, overwrite=T ) -->
<!-- # dbDisconnect(lab) -->
<!-- ``` -->

## Post Robot Quality Control
<!-- TODO: read up on ggplot2 to make a multipanel graph that is a representation of all of the plates and locations on the robot bench the way that you normally draw them...for example 1st plot in multipanel would just be  "D4588/P5" in the center of the graph space following the formula plan$source_plate / plan$source_loc -->
*For the plates that were put together on the robot on 8/3/2018 and 8/6/2018, the script to generate the robot plans was run several times in order to accomodate software glitches with the robot (it didn't want to go to some destination plate locations, sometimes P12, sometimes P9).  Because of this, all of the rows that had been added to the database had to be removed and resent to the database based on the csv's that the robot actually used.*


* Spin the plate down and examine the wells:  

**Other than A1 and A12, everything looks good**
 
  
* Pull up the csv in excel (from the actual drive you used on the robot with any real time changes made) and pare down the columns to the ones that will go into the database.
* Generate plate maps
```{r echo=FALSE, message=FALSE, warning=FALSE, fig.align='left'}
library(tidyverse)
source("../genomics/scripts/lab_helpers.R")

pool_csv <- read_csv(params$infile) 
# if there is a second file
another <- read_csv(params$infile2)
pool_csv <- rbind(pool_csv, another)
rm(another)
# if there is a third file
another <- read_csv(params$infile3)
pool_csv <- rbind(pool_csv, another)
rm(another)
# if there is a fourth file
another <- read_csv(params$infile4)
pool_csv <- rbind(pool_csv, another)
rm(another)

pool_csv <- pool_csv %>% 
  select(digest_id, dest_well, uL_in, water, DNA, pool) %>% 
  rename(well = dest_well, 
         vol_in = uL_in) %>% 
  mutate(pool = paste("P", formatC(as.numeric(substr(pool, 2, 6)), width = 3, format = "d", flag = 0), sep = ""), 
         date = params$date_of_work)

lig1 <- params$max_lig+1
lig2 <- params$max_lig+nrow(pool_csv)

pool_csv <- pool_csv %>% 
  mutate(ligation_id = paste("L", lig1:lig2, sep = ""))

map <- pool_csv %>% 
  select(well, ligation_id, pool) %>% 
  mutate(row = substr(well, 1, 1),
      row = factor(row, levels = c("H", "G", "F", "E", "D", "C", "B", "A")), 
      col = substr(well, 2, 3),
           col = factor(col, levels = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)))



regenomap <-  ggplot(map, aes(x = col, y= row, fill = pool, colour = "blue")) +
      geom_tile(colour = "black") # makes black lines between cells
    
    regenomap + 
      geom_text(aes(col, row, label = ligation_id), color = "black", size = 3) 
    # ggsave(paste("plots/", name$pool[1], "_map.pdf", sep = ""))
  
```


* Look at the notes made on the iPad:  
"room for error when using the robot: make sure to change both "transfer from file" csv's to the next round of csv's."
 
* Write the lines to the database
```{r echo=FALSE, message=FALSE, warning=FALSE}
# lab <- write_db("Laboratory")
# dbWriteTable(lab, "ligation", pool_csv, row.names=F, append = T)
# dbDisconnect(lab)
```

## Rebuilding robot rows

In case the robot documents were re-generated in Princeton and may have changed from the database version, I am re-creating the rows for the database based on the most recent version of the robot files.

**Import the data from the robot files**
```{r echo=FALSE, message=FALSE}
library(tidyverse)
library(knitr)
source("../genomics/scripts/lab_helpers.R")
files <- list.files("/Volumes/USB DISK/robot files/")

rows <- tibble()
for (i in files){
  dat <- read_csv(paste0("/Volumes/USB DISK/robot files/", i)) %>% 
    mutate(file = i)
  rows <- rbind(rows, dat)
}
rows <- distinct(rows) %>% 
  select(-X1)
rm(x, dat)
```
Double check that all of the pool names look correct and that there are 48 samples in each pool
```{r echo=FALSE, message=FALSE}
pools <- rows %>% 
  group_by(pool) %>% 
  summarise(count = n())
```
Pools P124 and P102 have too many samples, what is going on?
```{r echo=FALSE, message=FALSE}
strange <- rows %>% 
  filter(pool == "P124" | pool == "P102")
kable(strange)
```
P124 has duplicate rows because the file was adjusted into a new file - I just needed to run those last few rows again, I think because of a tip issue (had to re-arrange tips in the box)
```{r echo=FALSE, message=FALSE}
weird <- strange %>% 
  filter(pool == "P102") %>% 
  select(digest_id) %>% 
  distinct()
kable(weird)
```
It appears there are some duplicate digest_ids within P102 that are making it appear like more than 48 samples when really it is only 48.  However, it is possible that these samples were filled twice...D4496-D4431
```{r echo=FALSE, message=FALSE}
weirder <- strange %>% 
  filter(pool == "P102") %>% 
  group_by(digest_id) %>% 
  summarise(num = n())

weirder <- strange %>% 
  filter(digest_id >= "D4396" & digest_id <= "D4431", 
    file != "2018-08-039_a.csv")
```
Remove the duplicate rows
```{r echo=FALSE, message=FALSE}
rows <- rows %>% 
  filter(file != "2018-08-0320_c_orig.csv")

rows <- anti_join(rows, weirder)
```


Remove the columns that will not go into the database
```{r echo=FALSE, message=FALSE}
rows <- rows %>% 
  select(digest_id, dest_well, uL_in, water, DNA, pool) %>% 
  rename(vol_in = uL_in, 
    well = dest_well)

rows <- distinct(rows)

rows <- rows %>%
  mutate(num = as.numeric(substr(pool, 2,4)), 
    num = formatC(as.numeric(num), width = 3, format = "d", flag = 0), 
    pool = paste0("P", num))
rows <- rows %>% 
  mutate(date = "2018-08-21") %>% 
  select(-num)

# add ligation_id
wlab <- write_db("Laboratory")
lig <- dbReadTable(wlab, "ligation") %>% 
  select(ligation_id) %>% 
  summarize(max = max(ligation_id)) 

x <- as.numeric(substr(lig$max, 2, 5))
possibilities <- tibble(id = 1:9999) %>% 
  mutate(id = formatC(id, width = 4, format = "d", flag = 0), 
    id = paste0("L", id))

used <- dbReadTable(wlab, "ligation") %>% 
  select(ligation_id)

possibilities <- possibilities %>% 
  filter(!id %in% used$ligation_id)

# attach available ligation ids to current work
possibilities <- possibilities %>% 
  slice(1:nrow(rows))
rows <- cbind(rows, possibilities) 

rows <- rows %>% 
  rename(ligation_id = id)
```
Write the data to the database
```{r echo=FALSE, message=FALSE}


# dbWriteTable(wlab, "ligation", rows, row.names = F, append = T)
# dbDisconnect(wlab)
```

